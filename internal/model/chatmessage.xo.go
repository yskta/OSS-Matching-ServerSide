// Package model contains generated code for schema 'public'.
package model

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

// ChatMessage represents a row from 'public.chat_messages'.
type ChatMessage struct {
	ID               uuid.UUID    `json:"id"`                 // id
	JobApplicationID uuid.UUID    `json:"job_application_id"` // job_application_id
	SenderID         uuid.UUID    `json:"sender_id"`          // sender_id
	Content          string       `json:"content"`            // content
	IsRead           sql.NullBool `json:"is_read"`            // is_read
	CreatedAt        sql.NullTime `json:"created_at"`         // created_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [ChatMessage] exists in the database.
func (cm *ChatMessage) Exists() bool {
	return cm._exists
}

// Deleted returns true when the [ChatMessage] has been marked for deletion
// from the database.
func (cm *ChatMessage) Deleted() bool {
	return cm._deleted
}

// Insert inserts the [ChatMessage] to the database.
func (cm *ChatMessage) Insert(ctx context.Context, db DB) error {
	switch {
	case cm._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case cm._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.chat_messages (` +
		`id, job_application_id, sender_id, content, is_read, created_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`)`
	// run
	logf(sqlstr, cm.ID, cm.JobApplicationID, cm.SenderID, cm.Content, cm.IsRead, cm.CreatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, cm.ID, cm.JobApplicationID, cm.SenderID, cm.Content, cm.IsRead, cm.CreatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	cm._exists = true
	return nil
}

// Update updates a [ChatMessage] in the database.
func (cm *ChatMessage) Update(ctx context.Context, db DB) error {
	switch {
	case !cm._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case cm._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.chat_messages SET ` +
		`job_application_id = $1, sender_id = $2, content = $3, is_read = $4, created_at = $5 ` +
		`WHERE id = $6`
	// run
	logf(sqlstr, cm.JobApplicationID, cm.SenderID, cm.Content, cm.IsRead, cm.CreatedAt, cm.ID)
	if _, err := db.ExecContext(ctx, sqlstr, cm.JobApplicationID, cm.SenderID, cm.Content, cm.IsRead, cm.CreatedAt, cm.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [ChatMessage] to the database.
func (cm *ChatMessage) Save(ctx context.Context, db DB) error {
	if cm.Exists() {
		return cm.Update(ctx, db)
	}
	return cm.Insert(ctx, db)
}

// Upsert performs an upsert for [ChatMessage].
func (cm *ChatMessage) Upsert(ctx context.Context, db DB) error {
	switch {
	case cm._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.chat_messages (` +
		`id, job_application_id, sender_id, content, is_read, created_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`job_application_id = EXCLUDED.job_application_id, sender_id = EXCLUDED.sender_id, content = EXCLUDED.content, is_read = EXCLUDED.is_read, created_at = EXCLUDED.created_at `
	// run
	logf(sqlstr, cm.ID, cm.JobApplicationID, cm.SenderID, cm.Content, cm.IsRead, cm.CreatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, cm.ID, cm.JobApplicationID, cm.SenderID, cm.Content, cm.IsRead, cm.CreatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	cm._exists = true
	return nil
}

// Delete deletes the [ChatMessage] from the database.
func (cm *ChatMessage) Delete(ctx context.Context, db DB) error {
	switch {
	case !cm._exists: // doesn't exist
		return nil
	case cm._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.chat_messages ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, cm.ID)
	if _, err := db.ExecContext(ctx, sqlstr, cm.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	cm._deleted = true
	return nil
}

// ChatMessageByID retrieves a row from 'public.chat_messages' as a [ChatMessage].
//
// Generated from index 'chat_messages_pkey'.
func ChatMessageByID(ctx context.Context, db DB, id uuid.UUID) (*ChatMessage, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, job_application_id, sender_id, content, is_read, created_at ` +
		`FROM public.chat_messages ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	cm := ChatMessage{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&cm.ID, &cm.JobApplicationID, &cm.SenderID, &cm.Content, &cm.IsRead, &cm.CreatedAt); err != nil {
		return nil, logerror(err)
	}
	return &cm, nil
}

// JobApplication returns the JobApplication associated with the [ChatMessage]'s (JobApplicationID).
//
// Generated from foreign key 'chat_messages_job_application_id_fkey'.
func (cm *ChatMessage) JobApplication(ctx context.Context, db DB) (*JobApplication, error) {
	return JobApplicationByID(ctx, db, cm.JobApplicationID)
}

// User returns the User associated with the [ChatMessage]'s (SenderID).
//
// Generated from foreign key 'chat_messages_sender_id_fkey'.
func (cm *ChatMessage) User(ctx context.Context, db DB) (*User, error) {
	return UserByID(ctx, db, cm.SenderID)
}
